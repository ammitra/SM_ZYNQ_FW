#!/usr/bin/python
"""
usage: gen_ipus_addr_decode [options] <uhal_address_table.xml>

The script generates the address select logic in the
file for the ipbus system.

The script takes an uHAL compliant XML input file and prints out the vhdl module.

Note that full address decoding is not performed (would be very
inefficient with 32b address space), so slaves will appear at many
locations.

options:
   -v, --verbose                            verbose
   -d  --debug                              debug output
   -t <file>, --template=<file>             uses a different vhdl template file
                                            (default
                                            /opt/cactus/etc/uhal/tools/ipbus_addr_decode.vhd)
"""

from __future__ import print_function

import getopt
import sys
import os.path
import time
import logging
import math
import uhal

#===========================================================================================
# In Python 3 "xrange" doesn't exist, since Python 3's "range" is just as efficient as Python 2's "xrange"
if (sys.version_info[0] > 2):
    xrange = range

        
class BitArray:
    
    def __init__(self,value=0):
        self.length = 32
        if (value> (1<<self.length)-1):
            raise Exception("Value '%d' too big. It does not fit in %d bits\n" % (value,self.length))
        
        self.bits = [value>>i & 1 for i in xrange(self.length)]

    def __getitem__(self,index):
        return self.bits[index]
        
    def __and__(self,other):
        if not isinstance(other,BitArray):
            raise Exception("BitArray.__and__ method requires BitArray")

        result = BitArray()
        result.bits = [x & y for (x,y) in zip(self.bits,other.bits)]
        return result

    def __or__(self,other):
        if not isinstance(other,BitArray):
            raise Exception("BitArray.__and__ method requires BitArray")

        result = BitArray()
        result.bits = [x | y for (x,y) in zip(self.bits,other.bits)]
        return result
    
    def __invert__(self):
        result = BitArray()
        result.bits = [(x+1) % 2 for x in self.bits]
        return result
    
    def __str__(self):
        return "".join(map(lambda x: x and "1" or "0",self.bits[::-1]))

    def uint(self):
        result = 0
        for i,x in enumerate(self.bits):
            result += x << i
            
        return result

    def hex(self):
        return "0x%08x" % self.uint()

class node(object):
    
    def __init__(self, name, ref, flag, width = None, desc = None):
        self.name = name
        self.ref = ref
        self.flag = flag
        if width is None:
            self.width = 0
        else:
            self.width = width
        self.desc = list()
        if desc is not None: self.desc.append(desc)
        
    def sort(self):
        self.desc = sorted(self.desc, key = lambda x: x.ref.getAddress())
        
class nodetree(object):
	
    def __init__(self):
        self.root = node("TOP", None, False)
        
    def add(self, n):
        np = self.root
        m = n.name.split('.')
        for i in range(len(m) - 1):
            name = '.'.join(m[: i + 1])
            l = [x.name for x in np.desc]
            if name not in l:
                c = node(name, None, False)
                np.desc.append(c)
                np = c
            else:
                np = np.desc[l.index(name)]
        l = [x.name for x in np.desc]
        if n.name not in l:
            np.desc.append(n)
        else:
            np.desc[l.index(n.name)].ref = n.ref
            np.desc[l.index(n.name)].flag = n.flag
    
    def __str__(self):
        return self.dump(self.root, "")
    
    def dump(self, n, prefix):
        s = ""
        for i in n.desc:
            s = s + prefix + i.name + " " + hex(i.ref.getAddress()) + " " + hex(i.width) + " " + str(i.flag) + "\n"
            if i.desc: s = s + self.dump(i, prefix + "  ")
        return s

    def assign_width(self, n):
        errors = []
        self._assign_width(n, errors)
        return len(errors) == 0

    def _assign_width(self, n, errors_detected):
        n.sort()
        if n.ref is not None:
            addr = n.ref.getAddress()
        else:
            addr = 0
        max_addr = 0
        top_addr = 0
        if n.ref is not None and "width" in n.ref.getFirmwareInfo():
            n.width = int(n.ref.getFirmwareInfo()["width"])
        else:
            if not n.desc:
                log.error("Fatal error - no width parameter found for node: " + n.name)
                raise SystemExit(1)
            for i in n.desc:
                saddr = i.ref.getAddress()
                if saddr < max_addr:
                    log.error("Overlap between nodes detected: " + i.name + " " + hex(saddr) + " "+ hex(max_addr))
                    errors_detected.append(i.name)
                max_addr = saddr + pow(2, self._assign_width(i, errors_detected))
                if max_addr > top_addr:
                    top_addr = max_addr
            n.width = int(math.ceil(math.log(top_addr - addr,2)))
        if addr % pow(2, n.width) != 0:
            log.error("Node '" + n.name + "' at " + hex(addr) + ": Width, " + hex(n.width) + ", produces address mask " + hex(pow(2,n.width)) + " that is not aligned with node's base address")
            errors_detected.append(n.name)
        return n.width

    def get_nodes(self, n):
        l = list()
        if n.flag:
            l.append((n.name, n.ref.getAddress(), n.width))
        elif n.desc:
            for i in n.desc:
                l.extend(self.get_nodes(i))
        return l

#===========================================================================================

EXIT_CODE_INCORRECT_ARGUMENTS = 1
EXIT_CODE_ARG_PARSING_ERROR   = 2
EXIT_CODE_NODE_ADDRESS_ERRORS = 3


def padHex(n):
    return "0x" + hex(n)[2:].zfill(8)

def generateRecord(name,members):
    #Generate and print a VHDL record
    print("type " + name + " is record")
    maxNameLength = 25
    for member in members:
        if len(member) > maxNameLength:
            maxNameLength = len(member)

    for member in members:        
        print("  " + member + "".ljust(maxNameLength-len(member),' ') + "  : " + members[member]+";")
    print("end record "+name)


def getBitRange(mask):
    bits = bin(mask)[2:].zfill(32)
    start = -1
    end = -1    
    for i in range(len(bits)-1,0,-1):
        if end == -1:
            if bits[i] == '1':
                   end = i
        elif start == -1:
            if bits[i] == '0':
                start = i+1
                break
    return str(end)+" downto "+str(start)

def traverseTree(Node,padding,baseAddress,baseName):
    global action_ops
    baseName=Node.getPath()
    package_entries = dict()
    for childName in Node.getNodes():
        name = childName
        childNode = Node.getNode(childName)
        if childName.count('.') == 0:            
            if len(childNode.getNodes()) != 0 :
                package_entries[name] = (childNode.getPath()[4:]).replace('.','_')+"_t"
                traverseTree(childNode,padding+"\t",baseAddress,baseName)
            else:                
                bitCount = bin(childNode.getMask())[2:].count('1')
                if bitCount == 1:
                    package_entries[name] = "std_logic"
                else:
                    package_entries[name] = "std_logic_vector(" + str(bitCount-1) + " downto 0)"

                if childNode.getPermission() == uhal.NodePermission.READ:
                    if read_ops.has_key(childNode.getAddress()-baseAddress):
                        read_ops[childNode.getAddress()-baseAddress] = read_ops[childNode.getAddress()-baseAddress] + "outdata("+getBitRange(childNode.getMask())+") <= "+childNode.getPath()+";\n"
                    else:
                        read_ops[childNode.getAddress()-baseAddress] =                                                "outdata("+getBitRange(childNode.getMask())+") <= "+childNode.getPath()+";\n"
                elif childNode.getPermission() == uhal.NodePermission.READWRITE:
                    if read_ops.has_key(childNode.getAddress()-baseAddress):
                        read_ops[childNode.getAddress()-baseAddress] = read_ops[childNode.getAddress()-baseAddress] + "outdata("+getBitRange(childNode.getMask())+") <= "+childNode.getPath()+";\n"
                    else:
                        read_ops[childNode.getAddress()-baseAddress] =                                                "outdata("+getBitRange(childNode.getMask())+") <= "+childNode.getPath()+";\n"
                    if write_ops.has_key(childNode.getAddress()-baseAddress):
                        write_ops[childNode.getAddress()-baseAddress] = write_ops[childNode.getAddress()-baseAddress] + "outdata("+getBitRange(childNode.getMask())+") <= "+childNode.getPath()+";\n"
                    else:
                        write_ops[childNode.getAddress()-baseAddress] =                                                "outdata("+getBitRange(childNode.getMask())+") <= "+childNode.getPath()+";\n"
                elif childNode.getPermission() == uhal.NodePermission.WRITE:
                    if write_ops.has_key(childNode.getAddress()-baseAddress):
                        write_ops[childNode.getAddress()-baseAddress] = write_ops[childNode.getAddress()-baseAddress] + "outdata("+getBitRange(childNode.getMask())+") <= "+childNode.getPath()+";\n"
                    else:
                        write_ops[childNode.getAddress()-baseAddress] =                                                "outdata("+getBitRange(childNode.getMask())+") <= "+childNode.getPath()+";\n"
                    
                    action_ops+=childNode.getPath()+" <= (others => '0')\n "

                    
    generateRecord((baseName[4:]).replace('.','_')+"_t",package_entries)
                        

def main():    

    global read_ops
    global write_ops
    global action_ops

    read_ops = dict(list())
    write_ops = dict(list())
    action_ops = str()


    
    # configure logger
    global log
    log = logging.getLogger("main")
    formatter = logging.Formatter('%(name)s %(levelname)s: %(message)s')
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(formatter)
    log.addHandler(handler)
    log.setLevel(logging.WARNING)
    uhal.setLogLevelTo(uhal.LogLevel.WARNING)

    # options for verbosity level and VHDL template
    nflag = False
    template_fn = "/opt/cactus/etc/uhal/tools/ipbus_addr_decode.vhd"
    try:
        opts, args = getopt.getopt(sys.argv[1:], "vdnht:", ["verbose","debug","dry-run","help","template="])
    except getopt.GetoptError as err:
        log.critical(__doc__)
        sys.exit(EXIT_CODE_ARG_PARSING_ERROR)
    for o, a in opts:
        if o in ("-v", "--verbose"):
            log.setLevel(logging.INFO)
            uhal.setLogLevelTo(uhal.LogLevel.INFO)
        elif o in ("-d", "--debug"):
            log.setLevel(logging.DEBUG)
            uhal.setLogLevelTo(uhal.LogLevel.DEBUG)
        elif o in ("-h", "--help"):
            print(__doc__)
            sys.exit(0)
        elif o in ("-t", "--template"):
            template_fn = a
        elif o in ("-n", "--dry-run"):
            nflag = True

    # make sure that exactly one argument was given, later assumed to be the xml file name
    if len(args) != 1:
        log.critical("Incorrect usage - invalid number of arguments! Make sure that options come before argument.\n" + __doc__)
        sys.exit(EXIT_CODE_INCORRECT_ARGUMENTS)

    try:
        device = uhal.getDevice("dummy","ipbusudp-1.3://localhost:12345","file://" + args[0])
    except Exception:
        raise Exception("File '%s' does not exist or has incorrect format" % args[0])

    t = nodetree()
    for i in device.getNodes():
        d = device.getNode(i)
        if d.getPath().count('.') == 1:
            print("\n\n\n\n")
            print(d.getPath())
            print("\n")
            action_ops=""
            read_ops.clear()
            write_ops.clear()
            traverseTree(d,"\t",d.getAddress(),d.getPath())
            print(read_ops,'\n')
            print(write_ops,'\n')            
            print(action_ops,'\n')
            
                   
if __name__ == '__main__':
    main()
  
